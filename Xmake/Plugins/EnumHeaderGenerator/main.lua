-- Enum to header logic
import("core.base.option")
import("core.base.json")

local function _write_header(namespace, enum_name, base, enable_bitmask_ops, types, outfile)
	-- Each table entry is a line in the file
	local file_lines = {}
	table.insert(file_lines, "// ~~~ This file has been autogenerated using the EnumToHeader custom xmake rule ~~~\n\n")

	-- Namespace
	table.insert(file_lines, format("namespace %s", namespace))
	table.insert(file_lines, "{")  -- Open namespace

	-- Enum class declaration
	if base == json.null then
		table.insert(file_lines, format("\tenum class %s", enum_name))
	else
		table.insert(file_lines, format("\tenum class %s : %s", enum_name, base))
	end
	table.insert(file_lines, "\t{")  -- Open enum

	-- Types
	for _, kv in ipairs(types) do
		-- No value for this enum type
		if kv.Value == json.null then
			table.insert(file_lines, format("\t\t%s,", kv.Key))
		else  -- Value provided
			if type(kv.Value) == "number" then
				table.insert(file_lines, format("\t\t%s = %u,", kv.Key, kv.Value))
			elseif type(kv.Value) == "string" then
				table.insert(file_lines, format("\t\t%s = %s,", kv.Key, kv.Value))
			end
		end
	end
	table.insert(file_lines, "\t};")  -- Close enum
	table.insert(file_lines, "}")  -- Close namespace

	table.insert(file_lines, "")

	-- Bitmask ops
	if enable_bitmask_ops then
		table.insert(file_lines, format("RYU_ENUM_ENABLE_BITMASK_OPERATORS(::%s::%s)", namespace, enum_name))
	end

	table.insert(file_lines, "")
	-- Ryu namespace
	table.insert(file_lines, "namespace Ryu")
	table.insert(file_lines, "{")  -- Open namespace

	-- EnumToString
	table.insert(file_lines, "\ttemplate<>")
	table.insert(file_lines, format("\tinline constexpr std::string_view EnumToString<::%s::%s>(::%s::%s value)", namespace, enum_name, namespace, enum_name))
	table.insert(file_lines, "\t{")
	table.insert(file_lines, "\t\tswitch(value)")
	table.insert(file_lines, "\t\t{")
	table.insert(file_lines, format("\t\t\tusing enum ::%s::%s;", namespace, enum_name))
	for _, kv in ipairs(types) do
		table.insert(file_lines, format("\t\t\tcase %s: return \"%s\";", kv.Key, kv.Key))
	end
	table.insert(file_lines, "\t\t\tdefault: return \"<UNKNOWN>\";")
	table.insert(file_lines, "\t\t}")
	table.insert(file_lines, "\t}")

	table.insert(file_lines, "}")  -- Close namespace

	io.writefile(outfile, table.concat(file_lines, "\n"))

	if option.get("verbose") then
		print(format("[Ryu::EnumToHeader] Enum header generated for type: %s", enum_name))
	end
end

function main()
	local source_files = option.get("files")
	local output_dir = option.get("output_dir")

	for _, json_file in ipairs(source_files) do
		-- Read file as json
		local enum_json = json.loadfile(json_file)

		-- Get info
		local namespace = enum_json["Namespace"]
		local enum_name = enum_json["Name"]
		local enum_base = enum_json["Base"]
		local enable_bitmask_ops = enum_json["EnableBitMaskOps"]
		local types = enum_json["Types"]

		-- Get output file (AutogenDir + FileName + ".Generated.h")
		local outfile = path.join(output_dir, path.basename(json_file) .. ".Generated.h")
		_write_header(namespace, enum_name, enum_base, enable_bitmask_ops, types, outfile)
	end
end
